"""
The agreement is the actual, immutable reincarnation of an insurance that is active on a certain date date.
It carries the actual relevant information about the insurance, such as the form/do dates, premium, insurance
certificates as well as the ProductVariant.
"""
type Agreement {
  """
  The date this agreement took effect.
  """
  activeFrom: Date!
  """
  The last date this is in effect.
  """
  activeTo: Date!
  """
  The monthly premium of this agreement.
  """
  premium: Money!
  """
  The URL of the insurance certificate.
  """
  certificateUrl: Url
  """
  The ProductVariant of the agreement, which is the umbrella container for a lot of data related to the insurance,
  such as names, legal documents, perils etc.
  """
  productVariant: ProductVariant!
  """
  The reason this agreement was created, useful to distinguish between renewals and other creations for instance.
  """
  creationCause: AgreementCreationCause!
  """
  A localized list of key/value pairs the define the properties of this insurance.
  """
  displayItems: [AgreementDisplayItem!]!
  """
  Number co insured on the agreement. Null if not supported.
  """
  numberCoInsured: Int
}
"""
The `Int` scalar type represents non-fractional signed whole numeric values. Int can represent values between -(2^31) and 2^31 - 1.
"""
scalar Int
enum AgreementCreationCause {
  """
  No creation cause is known - this is due to the agreement being older than when we started tracking
  creation cause.
  """
  UNKNOWN
  """
  This agreement was created as part of a contract creation. This means it's the first agreement of said contract.
  """
  NEW_CONTRACT
  """
  This agreement was created as part of the automatic renewal process of insurances. Usually yearly.
  """
  RENEWAL
  """
  This agreement was created by some kind of intervening change to the insurance, such as a move, co-insured change
  or similar.
  """
  MIDTERM_CHANGE
}
"""
A localized container of title/value/subtitle tuples to display in a table.
"""
type AgreementDisplayItem {
  displayTitle: String!
  displaySubtitle: String
  displayValue: String!
}
"""
The `String` scalar type represents textual data, represented as UTF-8 character sequences. The String type is most often used by GraphQL to represent free-form human-readable text.
"""
scalar String
enum AppPlatform {
  IOS
  ANDROID
}
type AvailablePaymentMethodsResponse {
  paymentMethodsResponse: PaymentMethodsResponse!
}
input BrowserInfo {
  userAgent: String!
  acceptHeader: String!
  language: String!
  colorDepth: Int!
  screenHeight: Int!
  screenWidth: Int!
  timeZoneOffset: Int!
  javaEnabled: Boolean!
}
"""
The `Boolean` scalar type represents `true` or `false`.
"""
scalar Boolean
type CampaignDiscount {
  """
  The type of discount, determines the relevancy of the other fields.
  """
  type: CampaignDiscountType!
  months: Int!
  amount: Money!
  percentage: Int!
}
enum CampaignDiscountType {
  """
  A fixed deduction of cost. This means `CampaignDiscount.amount` is non-zero.
  """
  MONTHLY_COST
  """
  Free for a number of months. This means `CampaignDiscount.months` is non-zero.
  """
  FREE_MONTHS
  """
  A percentage discount for a number of months. This means both `CampaignDiscount.months`
  and `CampaignDiscount.percentage` are non-zero.
  """
  MONTHLY_PERCENTAGE
  """
  A percentage discount indefinitely. This means `CampaignDiscount.percentage` is non-zero.
  """
  INDEFINITE_PERCENTAGE
  """
  A hack-case to support tagging the member with some kind of partner source. This isn't an actual discount,
  but we want to display it someplace.
  """
  VISIBLE_NO_DISCOUNT
}
type Cart {
  id: UUID!
  """
  The entries is the list of `ProductOffers` that have been placed in the cart, and thus are
  marked for being part of a potential checkout.
  """
  entries: [ProductOffer!]!
  """
  The total cost values of this cart, in terms of monthly recurring payments.
  """
  cost: CartCost!
  """
  If false, campaigns cannot be added to this cart.
  """
  campaignsEnabled: Boolean!
  """
  Currently redeemed campaign, if any
  It's possible that campaignsEnabled is set to false, this means campaign is read-only and cannot be removed
  """
  redeemedCampaign: RedeemedCampaign
}
type CartCost {
  """
  How much price was reduced.
  """
  discount: Money!
  """
  Original price.
  """
  gross: Money!
  """
  Price you will pay after discount.
  """
  net: Money!
}
type Chat {
  id: ID!
  """
  If hasNext = true the the list of messages is not complete, when you want more include the cursor in next query
  """
  hasNext: Boolean!
  """
  The cursor to include if you want to fetch more messages
  """
  nextUntil: Instant!
  """
  The list of messages.
  """
  messages: [ChatMessage!]!
  """
  A message containing important information to the user, usually to display in a
  sticky fashion at the bottom of the chat.
  """
  bannerText: Markdown
}
"""
The `ID` scalar type represents a unique identifier, often used to refetch an object or as key for a cache. The ID type appears in a JSON response as a String; however, it is not intended to be human-readable. When expected as an input type, any string (such as `"4"`) or integer (such as `4`) input value will be accepted as an ID.
"""
scalar ID
type ChatGif {
  url: Url
}
interface ChatMessage {
  id: ID!
  sender: ChatMessageSender!
  sentAt: Instant!
}
"""
This describes a context in which the chat was opened to ask questions.
The system uses this a hint to the category of the question that was sent.
"""
enum ChatMessageContext {
  HELP_CENTER_PAYMENTS
  HELP_CENTER_CLAIMS
  HELP_CENTER_MY_INSURANCE
  HELP_CENTER_COVERAGE
  HELP_CENTER_CAR
  HELP_CENTER_PET
  HELP_CENTER_BUILDING
  HELP_CENTER_HOME
  HELP_CENTER_TRAVEL
  HELP_CENTER_TERMINATIONS
  HELP_CENTER_CONTRACT_CHANGES
}
type ChatMessageFile implements ChatMessage {
  id: ID!
  sender: ChatMessageSender!
  sentAt: Instant!
  signedUrl: Url!
  mimeType: String!
}
input ChatMessageFileInput {
  uploadToken: ID!
  context: ChatMessageContext
}
type ChatMessageMutationOutput {
  message: ChatMessage
  userError: UserError
}
type ChatMessagePage {
  messages: [ChatMessage!]!
  olderToken: String
  newerToken: String
}
enum ChatMessageSender {
  MEMBER
  HEDVIG
}
type ChatMessageText implements ChatMessage {
  id: ID!
  sender: ChatMessageSender!
  sentAt: Instant!
  text: String!
}
input ChatMessageTextInput {
  text: String!
  context: ChatMessageContext
}
type ChatSendOutcome {
  """
  Localized message if the user sends something invalid
  """
  error: UserError
  """
  The message to manually patch in the cache at the end of the messages list for immediate user feedback
  """
  message: ChatMessage
  """
  Status message to show the member if the message was successfully sent
  """
  status: ChatStatus
}
type ChatStatus {
  message: String!
}
scalar CheckoutPaymentsAction
type Claim {
  id: ID!
  """
  Return the relevant conversation for this claim.
  These conversations can be one of two kinds:
  - either it will be a dedicated conversation for this specific claim
  - or it will be the "legacy conversation", containing the entire old chat history
  The first one will be given for claims that are newer, created after the release of conversations.
  The second one for all other (older) claims.
  """
  conversation: Conversation!
  outcome: ClaimOutcome
  status: ClaimStatus
  submittedAt: DateTime!
  payoutAmount: Money
  payouts: [ClaimPayoutDetails!]!
  associatedTypeOfContract: String
  closedAt: DateTime
  audioUrl: String
  memberFreeText: String
  claimType: String
  incidentDate: Date
  """
  Terms & conditions for the claim found using claims contractId and dateOfOccurrence, otherwise null.
  """
  productVariant: ProductVariant
  """
  Use this relative path as the target for file uploads.
  This needs to be placed on top of the base URL of the API (usually `https://gateway.hedvig.com`
  or the staging equivalent) like so: "<baseUrl><targetFileUploadUri>".
  This target accepts multipart file uploads, and will automatically attach the uploaded files to the given claim.
  Therefore, the same claim can be refreshed in GraphQL and it should be visible in the `Claim.files` field.
  """
  targetFileUploadUri: String!
  """
  A list of all the member-visible, uploaded files for this claim.
  """
  files: [ClaimFile!]!
}
type ClaimFile {
  id: ID!
  """
  The name of the file - usually what the person who uploaded named the file originally.
  """
  name: String!
  """
  The mime/media type of the file. See: https://en.wikipedia.org/wiki/Media_type
  """
  mimeType: String!
  """
  The URL where the file can be read from.
  Note that these, for security reasons, are signed and somewhat short lived - which means that the the URL might
  become invalid for fetching. This can be fixed by simply re-loading the claim.
  """
  url: Url!
  """
  A URL that contains a smaller, thumbnail version, of the file. Only applicable if the file is an image.
  It is no guarantee that the thumbnail has been generated successfully, so clients should either fallback to
  the real URL or a placeholder.
  """
  thumbnailUrl: Url
}
type ClaimMutationOutput {
  claim: Claim
  userError: UserError
}
enum ClaimOutcome {
  PAID
  NOT_COMPENSATED
  NOT_COVERED
}
type ClaimPayoutDetails {
  purchasePrice: Money
  purchaseDate: DateTime
  ageDeduction: Money
  valuation: Money!
  deductible: Money!
  paidOut: Money!
}
enum ClaimStatus {
  CREATED
  IN_PROGRESS
  CLOSED
  REOPENED
}
input CoInsuredInput {
  firstName: String
  lastName: String
  ssn: String
  birthdate: Date
}
"""
This is a type that describes a common claim scenario. This is meant as user-presentable content,
and does not resemble any one particular claim.
"""
type CommonClaimDescription {
  id: ID!
  icon: Icon!
  title: String!
  layout: CommonClaimLayout!
}
union CommonClaimLayout = CommonClaimLayoutTitleAndBulletPoints|CommonClaimLayoutEmergency
type CommonClaimLayoutBulletPoint {
  icon: Icon!
  title: String!
  description: String!
}
type CommonClaimLayoutEmergency {
  color: HedvigColor!
  title: String!
  """
  Phone Number on E.164-format
  """
  emergencyNumber: String!
}
type CommonClaimLayoutTitleAndBulletPoints {
  color: HedvigColor!
  title: String!
  buttonTitle: String!
  bulletPoints: [CommonClaimLayoutBulletPoint!]!
}
type ConsentResponse {
  consentGiven: Boolean!
}
"""
A contract is a container for a specific insurance, and contains a history of the versions of that insurance,
called Agreements.
"""
type Contract {
  id: UUID!
  """
  If the insurance has been switched from a different company, this contains the relevant data
  """
  externalInsuranceCancellation: ContractExternalInsuranceCancellation
  """
  The first date this insurance became active - i.e. the "from date" of the first agreement.
  """
  masterInceptionDate: Date!
  """
  The last date this insurance will be active, if there is one.
  """
  terminationDate: Date
  """
  Whether or not this contract has termination status because of missed payments
  """
  terminationDueToMissedPayments: Boolean!
  """
  The display name of the "exposure" of this insurance - i.e. the 'object' being insured. This could be
  the address of an apartment, or the person having accident insurance, or the dog being insured etc.
  """
  exposureDisplayName: String!
  """
  The currently active/relevant agreement for this contract.
  """
  currentAgreement: Agreement!
  """
  A possible upcoming change of agreement. If there are multiple upcoming changes, this one will return
  the first.
  """
  upcomingChangedAgreement: Agreement
  """
  Whether or not this contract can be changes through the 'MoveIntent' API.
  """
  supportsMoving: Boolean!
  """
  Whether or not this co-insured for contract can be changed through the 'MidtermChange' API.
  """
  supportsCoInsured: Boolean!
  """
  Whether or not travel certificate can be created for the contract
  """
  supportsTravelCertificate: Boolean!
  """
  Current state of co-insured including upcoming changes.
  If current agreement doesn't support co-insured, this is null
  """
  coInsured: [ContractCoInsured!]
  """
  User messages to show due to self change is blocked.
  """
  selfChangeBlockers: ContractSelfChangeBlockers
}
type ContractBankSigneringCancellation {
  approveByDate: Date!
  url: String
}
"""
Breakdown of the upcoming charge by contract
"""
type ContractChargeBreakdownItem {
  """
  Contract for which the charge is calculated
  """
  gross: Money!
  """
  Connection with the Contract
  """
  contract: Contract!
}
"""
A co-insured on contract.
"""
type ContractCoInsured {
  """
  firstName + lastName + birthDate if all are present, otherwise null
  """
  id: ID
  """
  First name.
  """
  firstName: String
  """
  Last name.
  """
  lastName: String
  """
  National identification number if any.
  """
  ssn: String
  """
  Co-insured birthdate.
  """
  birthdate: Date
  """
  The date this co-insured will be removed.
  """
  terminatesOn: Date
  """
  The date this co-insured will be added.
  """
  activatesOn: Date
  """
  Whether or not any of firstName, lastName, ssn or birthdate is missing and needs to be added.
  """
  hasMissingInfo: Boolean!
}
"""
Information about ongoing or completed cancellations of insurances with different companies
"""
type ContractExternalInsuranceCancellation {
  id: UUID!
  externalInsurer: ExternalInsurer!
  status: ContractExternalInsuranceCancellationStatus!
  type: ContractExternalInsuranceCancellationType!
  bankSignering: ContractBankSigneringCancellation
}
enum ContractExternalInsuranceCancellationStatus {
  """
  The contract has been created, and has the necessary information cancelling, but the cancellation process has not been initiated
  """
  NOT_INITIATED
  """
  The cancellation process is in progress and requires no more actions from the client
  """
  INITIATED
  """
  The cancellation process is complete
  """
  COMPLETED
}
enum ContractExternalInsuranceCancellationType {
  BANKSIGNERING
}
type ContractSelfChangeBlocker {
  reason: String!
}
type ContractSelfChangeBlockers {
  """
  Message to show if self change of co-insured is currently blocked. This will usually be sat if
  contract is in a renewal period or there exists future changes on the contract.
  """
  coInsured: ContractSelfChangeBlocker
}
type Conversation {
  id: UUID!
  title: String!
  subtitle: String!
  createdAt: DateTime!
  isOpen: Boolean!
  newestMessage: ChatMessage
  messagePage(olderToken: String, newerToken: String): ChatMessagePage!
  statusMessage: String
}
input ConversationSendMessageInput {
  id: UUID!
  text: String
  fileUploadToken: String
}
input ConversationStartInput {
  """
  The to-be `Conversation.id` of the returned Conversation. Should be a UUID v4.
  """
  id: UUID!
}
enum CountryCode {
  """
  Sweden
  """
  SE
  """
  Denmark
  """
  DK
  """
  Norway
  """
  NO
}
type CrossSell {
  id: ID!
  title: String!
  description: String!
  about: String!
  imageUrl: String!
  blurHash: String!
  """
  A url pointing to a product page where the member can complete the purchase
  """
  storeUrl: String!
  productVariants: [ProductVariant!]!
  type: CrossSellType!
}
enum CrossSellType {
  CAR
  HOME
  ACCIDENT
  PET
}
enum CurrencyCode {
  """
  Swedish Kronor (SEK).
  """
  SEK
  """
  Danish Kroner (DKK).
  """
  DKK
  """
  Norwegian Kroner (NOK).
  """
  NOK
}
scalar Date
scalar DateTime
type DirectDebitResponse2 {
  url: String!
  orderId: String!
}
type Entrypoint {
  id: ID!
  displayName: String!
  options: [EntrypointOption!]
}
type EntrypointGroup {
  id: ID!
  displayName: String!
  iconUrl: Url! @deprecated(reason: "Should not be used")
  entrypoints: [Entrypoint!]!
}
type EntrypointOption {
  id: ID!
  displayName: String!
}
input EntrypointSearchInput {
  entrypointGroupId: ID
  searchString: String
  limit: Int
  type: EntrypointType!
}
enum EntrypointType {
  CLAIM
}
"""
Input for `Mutation.sendEvent`
"""
input EventInput {
  """
  The id of the event.
  """
  id: ID!
  """
  The session the event belongs to.
  """
  sessionId: ID!
  """
  The client timestamp.
  """
  clientTimestamp: DateTime!
  """
  The event type.
  """
  type: String!
  """
  The event data.
  """
  data: JSON!
}
type ExternalInsuranceCancellation {
  """
  Determines if and how we can help the user with cancellation.
  """
  option: ExternalInsuranceCancellationOption!
  """
  True if cancellation has been requested.
  """
  requested: Boolean!
  """
  The latest date the insurance needs to be approved with banksignering
  """
  bankSigneringApproveByDate: Date!
  """
  The currently set external insurer.
  """
  externalInsurer: ExternalInsurer
}
enum ExternalInsuranceCancellationOption {
  """
  We cannot offer cancellation.
  """
  NONE
  """
  We can offer cancellation based on internal IEX work at Hedvig.
  """
  IEX
  """
  We can offer BankSignering.
  """
  BANKSIGNERING
  """
  BankSignering is supported for the insurance but cannot be done with the given start date
  """
  BANKSIGNERING_INVALID_RENEWAL_DATE
}
type ExternalInsurer {
  id: ID!
  displayName: String!
  insurelyId: String
}
type FirstVetAction {
  sections: [FirstVetSection!]!
}
type FirstVetSection {
  title: String
  description: String
  buttonTitle: String
  url: String
}
type Flow {
  id: ID!
  currentStep: FlowStep!
  progress: FlowProgress
  context: FlowContext!
}
type FlowClaimAudioContent {
  """
   The url to get audio data from S3 
  """
  signedUrl: Url!
  """
   The stored url to be used in the next step input 
  """
  audioUrl: Url!
}
input FlowClaimAudioRecordingInput {
  audioUrl: Url
  freeText: String
}
type FlowClaimAudioRecordingStep implements FlowStep {
  id: ID!
  questions: [String!]!
  audioContent: FlowClaimAudioContent
  freeTextAvailable: Boolean!
  freeTextQuestions: [String!]!
  freeText: String
}
type FlowClaimAutomaticAutogiroPayout implements FlowClaimCheckoutMethod {
  id: ID!
  displayName: String!
  amount: Money!
}
input FlowClaimAutomaticAutogiroPayoutInput {
  amount: Float!
}
"""
The `Float` scalar type represents signed double-precision fractional values as specified by [IEEE 754](https://en.wikipedia.org/wiki/IEEE_floating_point).
"""
scalar Float
interface FlowClaimCheckoutMethod {
  id: ID!
}
input FlowClaimConfirmEmergencyInput {
  confirmEmergency: Boolean!
}
type FlowClaimConfirmEmergencyOption {
  displayName: String!
  value: Boolean!
}
type FlowClaimConfirmEmergencyStep implements FlowStep {
  id: ID!
  text: String!
  confirmEmergency: Boolean
  options: [FlowClaimConfirmEmergencyOption!]!
}
type FlowClaimContractOption {
  id: ID!
  displayName: String!
}
input FlowClaimContractSelectInput {
  contractId: UUID
}
type FlowClaimContractSelectStep implements FlowStep {
  id: ID!
  options: [FlowClaimContractOption!]!
}
input FlowClaimDateOfOccurrenceInput {
  dateOfOccurrence: Date
}
input FlowClaimDateOfOccurrencePlusLocationInput {
  dateOfOccurrence: Date
  location: ID
  subLocation: String
}
type FlowClaimDateOfOccurrencePlusLocationStep implements FlowStep {
  id: ID!
  dateOfOccurrenceStep: FlowClaimDateOfOccurrenceStep!
  locationStep: FlowClaimLocationStep!
}
type FlowClaimDateOfOccurrenceStep implements FlowStep {
  id: ID!
  dateOfOccurrence: Date
  maxDate: Date!
}
type FlowClaimDeflectChatStep implements FlowStep {
  id: ID!
}
type FlowClaimDeflectEirStep implements FlowStep {
  id: ID!
  partners: [FlowClaimDeflectPartner!]!
}
type FlowClaimDeflectEmergencyStep implements FlowStep {
  id: ID!
  partners: [FlowClaimDeflectPartner!]!
}
type FlowClaimDeflectGlassDamageStep implements FlowStep {
  id: ID!
  partners: [FlowClaimDeflectPartner!]!
}
type FlowClaimDeflectPartner {
  id: ID!
  imageUrl: Url
  url: Url
  phoneNumber: String
}
type FlowClaimDeflectPestsStep implements FlowStep {
  id: ID!
  partners: [FlowClaimDeflectPartner!]!
}
type FlowClaimDeflectTowingStep implements FlowStep {
  id: ID!
  partners: [FlowClaimDeflectPartner!]!
}
type FlowClaimFailedStep implements FlowStep {
  id: ID!
}
type FlowClaimFileUpload {
  """
   The url to get file data from S3 
  """
  signedUrl: Url!
  """
   The stored reference to be used in the next step input 
  """
  fileId: ID!
  """
   The mime/media type of the file. See: https://en.wikipedia.org/wiki/Media_type 
  """
  mimeType: String!
  """
   The file name 
  """
  name: String!
}
input FlowClaimFileUploadInput {
  fileIds: [ID!]!
}
type FlowClaimFileUploadStep implements FlowStep {
  id: ID!
  title: String!
  targetUploadUrl: String!
  uploads: [FlowClaimFileUpload!]!
}
interface FlowClaimInfo {
  id: ID!
  value: ValueType
  requires: [FlowClaimInfoRequiresValue!]
}
type FlowClaimInfoDate implements FlowClaimInfo {
  id: ID!
  label: String!
  requires: [FlowClaimInfoRequiresValue!]
  value: ValueDate
  max: Date
  min: Date
}
type FlowClaimInfoInteger implements FlowClaimInfo {
  id: ID!
  label: String!
  requires: [FlowClaimInfoRequiresValue!]
  value: ValueInteger
  max: Int!
  min: Int!
  isSelectable: Boolean!
}
type FlowClaimInfoRequiresValue {
  id: ID!
  value: ValueType!
  operator: ID!
}
type FlowClaimInfoSelect implements FlowClaimInfo {
  id: ID!
  label: String!
  requires: [FlowClaimInfoRequiresValue!]
  value: ValueArray
  options: [FlowClaimInfoSelectOption!]!
  isMulti: Boolean!
}
type FlowClaimInfoSelectOption {
  displayName: String!
  value: String!
}
type FlowClaimInfoStep implements FlowStep {
  id: ID!
  infos: [[FlowClaimInfo!]!]!
}
input FlowClaimInfoStepInput {
  values: [FlowClaimInfoValueInput!]!
}
type FlowClaimInfoText implements FlowClaimInfo {
  id: ID!
  label: String!
  requires: [FlowClaimInfoRequiresValue!]
  value: ValueString
}
input FlowClaimInfoValueInput {
  id: ID!
  stringValue: String
  integerValue: Int
  booleanValue: Boolean
  arrayValue: [String!]
  dateValue: Date
}
type FlowClaimInfoYesNo implements FlowClaimInfo {
  id: ID!
  label: String!
  requires: [FlowClaimInfoRequiresValue!]
  value: ValueBoolean
}
input FlowClaimItemBrandInput {
  itemTypeId: ID!
  itemBrandId: ID!
}
type FlowClaimItemBrandOption {
  displayName: String!
  itemTypeId: ID!
  itemBrandId: ID!
}
input FlowClaimItemModelInput {
  itemModelId: UUID!
}
type FlowClaimItemModelOption {
  displayName: String!
  imageUrl: Url
  itemTypeId: ID!
  itemBrandId: ID!
  itemModelId: UUID!
}
type FlowClaimItemProblemOption {
  displayName: String!
  itemProblemId: ID!
}
input FlowClaimLocationInput {
  location: ID
  subLocation: String
}
type FlowClaimLocationOption {
  displayName: String!
  value: ID!
}
type FlowClaimLocationStep implements FlowStep {
  id: ID!
  location: ID
  options: [FlowClaimLocationOption!]!
  subOptions: [FlowClaimSubLocationOption!]
}
type FlowClaimPersonOption {
  isHolder: Boolean!
  isSelected: Boolean!
  fullName: String
  ssn: String
}
input FlowClaimPersonSelectedInput {
  isHolder: Boolean!
  fullName: String!
  ssn: String
}
input FlowClaimPersonSelectInput {
  selected: [FlowClaimPersonSelectedInput!]!
}
type FlowClaimPersonSelectStep implements FlowStep {
  id: ID!
  options: [FlowClaimPersonOption!]!
}
input FlowClaimPhoneNumberInput {
  phoneNumber: String!
}
type FlowClaimPhoneNumberStep implements FlowStep {
  id: ID!
  phoneNumber: String!
}
interface FlowClaimSingleItemCheckoutCompensation {
  id: ID!
  deductible: Money!
  payoutAmount: Money!
}
input FlowClaimSingleItemCheckoutInput {
  automaticAutogiro: FlowClaimAutomaticAutogiroPayoutInput
}
type FlowClaimSingleItemCheckoutRepairCompensation implements FlowClaimSingleItemCheckoutCompensation {
  id: ID!
  repairCost: Money!
  deductible: Money!
  payoutAmount: Money!
}
type FlowClaimSingleItemCheckoutStep implements FlowStep {
  id: ID!
  price: Money! @deprecated(reason: "Use compensation instead")
  depreciation: Money! @deprecated(reason: "Use compensation instead")
  deductible: Money! @deprecated(reason: "Use compensation instead")
  payoutAmount: Money! @deprecated(reason: "Use compensation instead")
  compensation: FlowClaimSingleItemCheckoutCompensation!
  availableCheckoutMethods: [FlowClaimCheckoutMethod!]!
  singleItemStep: FlowClaimSingleItemStep
}
type FlowClaimSingleItemCheckoutValueCompensation implements FlowClaimSingleItemCheckoutCompensation {
  id: ID!
  price: Money!
  depreciation: Money!
  deductible: Money!
  payoutAmount: Money!
}
input FlowClaimSingleItemInput {
  purchasePrice: Float
  purchaseDate: Date
  itemProblemIds: [ID!]
  itemBrandInput: FlowClaimItemBrandInput
  itemModelInput: FlowClaimItemModelInput
  customName: String
}
type FlowClaimSingleItemStep implements FlowStep {
  id: ID!
  preferredCurrency: CurrencyCode!
  purchasePrice: Money
  purchasePriceApplicable: Boolean!
  purchaseDate: Date
  selectedItemProblems: [ID!]!
  availableItemProblems: [FlowClaimItemProblemOption!]
  selectedItemBrand: ID
  availableItemBrands: [FlowClaimItemBrandOption!]
  selectedItemModel: ID
  availableItemModels: [FlowClaimItemModelOption!]
  customName: String
}
input FlowClaimStartInput {
  entrypointId: ID
  entrypointOptionId: ID
  supportedSteps: [ID!]
}
type FlowClaimSubLocationOption {
  parentId: ID!
  displayName: String!
  value: String!
}
type FlowClaimSuccessStep implements FlowStep {
  id: ID!
}
input FlowClaimSummaryInput {
  dateOfOccurrence: Date
  location: ID
  purchasePrice: Float
  purchaseDate: Date
  itemProblemIds: [ID!]
  itemBrandInput: FlowClaimItemBrandInput
  itemModelInput: FlowClaimItemModelInput
  customName: String
}
type FlowClaimSummaryStep implements FlowStep {
  id: ID!
  title: String!
  subtitle: String
  dateOfOccurrenceStep: FlowClaimDateOfOccurrenceStep!
  locationStep: FlowClaimLocationStep!
  singleItemStep: FlowClaimSingleItemStep
  fileUploadStep: FlowClaimFileUploadStep
  audioRecordingStep: FlowClaimAudioRecordingStep
}
scalar FlowContext
type FlowProgress {
  clearedSteps: Int!
  totalSteps: Int!
}
interface FlowStep {
  id: ID!
}
input FlowTerminationDateInput {
  terminationDate: Date!
}
type FlowTerminationDateStep implements FlowStep {
  id: ID!
  minDate: Date!
  maxDate: Date!
}
input FlowTerminationDeletionInput {
  """
  This has no significance and is ignored by the backend. It exists to satisfy some codegen limitations
  """
  confirmed: Boolean!
}
type FlowTerminationDeletionStep implements FlowStep {
  id: ID!
  disclaimer: String! @deprecated(reason: "Unnecessary field")
}
type FlowTerminationFailedStep implements FlowStep {
  id: ID!
}
input FlowTerminationStartInput {
  contractId: ID!
}
type FlowTerminationSuccessStep implements FlowStep {
  id: ID!
  terminationDate: Date
  surveyUrl: String! @deprecated(reason: "Use the survey step instead")
}
input FlowTerminationSurveyDataInput {
  optionId: ID!
  """
  User submitted text feedback, if any
  """
  text: String
}
input FlowTerminationSurveyInput {
  data: FlowTerminationSurveyDataInput!
}
type FlowTerminationSurveyOption {
  id: ID!
  title: String!
  suggestion: FlowTerminationSurveyOptionSuggestion
  feedBack: FlowTerminationSurveyOptionFeedback
  subOptions: [FlowTerminationSurveyOption!]
}
type FlowTerminationSurveyOptionFeedback {
  id: ID!
  isRequired: Boolean!
}
interface FlowTerminationSurveyOptionSuggestion {
  id: ID!
}
type FlowTerminationSurveyOptionSuggestionAction implements FlowTerminationSurveyOptionSuggestion {
  id: ID!
  action: FlowTerminationSurveyRedirectAction!
}
type FlowTerminationSurveyOptionSuggestionRedirect implements FlowTerminationSurveyOptionSuggestion {
  id: ID!
  url: String!
  description: String!
  buttonTitle: String!
}
enum FlowTerminationSurveyRedirectAction {
  UPDATE_ADDRESS
}
type FlowTerminationSurveyStep implements FlowStep {
  id: ID!
  options: [FlowTerminationSurveyOption!]!
}
enum HedvigColor {
  Pink
  Turquoise
  Purple
  DarkPurple
  BlackPurple
  DarkGray
  LightGray
  White
  Black
  OffBlack
  OffWhite
  Yellow
}
type Icon {
  variants: IconVariants!
}
type IconVariant {
  pdfUrl: String!
  svgUrl: String!
}
type IconVariants {
  light: IconVariant!
  dark: IconVariant!
}
scalar Instant
type InsurableLimit {
  label: String!
  limit: String!
  description: String!
  type: InsurableLimitType!
}
enum InsurableLimitType {
  DEDUCTIBLE
  DEDUCTIBLE_NATURE_DAMAGE
  DEDUCTIBLE_ALL_RISK
  INSURED_AMOUNT
  GOODS_INDIVIDUAL
  GOODS_FAMILY
  TRAVEL_DAYS
  MEDICAL_EXPENSES
  LOST_LUGGAGE
  BIKE
  PERMANENT_INJURY
  TREATMENT
  DENTAL_TREATMENT
  TRAVEL_ILLNESS_INJURY_TRANSPORTATION_HOME
  TRAVEL_DELAYED_ON_TRIP
  TRAVEL_DELAYED_LUGGAGE
  TRAVEL_CANCELLATION
}
type InsuranceDocument {
  displayName: String!
  url: String!
  type: InsuranceDocumentType!
}
enum InsuranceDocumentType {
  TERMS_AND_CONDITIONS
  PRE_SALE_INFO_EU_STANDARD
  PRE_SALE_INFO
  GENERAL_TERMS
  PRIVACY_POLICY
}
type InsuranceFaq {
  headline: String!
  body: String
}
type InsuranceHighlight {
  title: String!
  description: String!
}
input InsurelyInitiateIframeDataCollectionInput {
  collectionId: String!
  partner: String
}
type InsurelyInitiateIframeDataCollectionOutput {
  dataCollectionId: ID!
}
scalar JSON
type LinkInfo {
  url: Url!
  buttonText: String!
}
type Location {
  street: String
}
"""
This is a string scalar that contains markdown - and is expected to be rendered using some
markdown-compatible renderer in the client.
"""
scalar Markdown
"""
A 'Member' is the central user-like concept of our platform, referring to someone who has bought insurance
with Hedvig and is now as we call is a "member".
The Member type in our schema must always refer to the member based on the current authentication, i.e. the
subject in the bearer token of the Authorization header.
This type must never be used in an unauthenticated context, and it must always refer to the member in the
authorization header. This is usually done either by:
- Returning it from `Query.currentMember`
- or from a mutation with return type `MemberMutationOutput`, which will refer to the authenticated member.
This is federated across multiple subgraphs, which enables us to attach data to it that "belongs to the
currently authenticated member", such as your "active contracts" etc. These could have just as easily been placed
at the top level like `Query.activeContracts`, respecting the current authentication, but placing them under
`Member` gives a more intuitive model when interacting with it from the outside perspective.
"""
type Member {
  id: ID!
  """
  Upcoming charge info, null in case of pending or fully settled members
  """
  futureCharge: MemberCharge
  """
  List of all past charges, this list will be empty in case of pending members
  """
  pastCharges: [MemberCharge!]!
  upcomingCharge: MemberUpcomingCharge @deprecated(reason: "Use futureCharge instead")
  chargeHistory: [MemberChargeHistoryEntry!]! @deprecated(reason: "Use pastCharges instead")
  conversations: [Conversation!]!
  legacyConversation: Conversation
  claims: [Claim!]!
  firstName: String!
  lastName: String!
  ssn: String
  email: String!
  countryCode: CountryCode!
  phoneNumber: String
  language: String
  """
  Carries messages to be shown to a logged in member, such as possible delays
  in service or outage announcements.
  """
  importantMessages: [MemberImportantMessage!]!
  partnerData: PartnerData
  hasActivePaymentConnection: Boolean! @deprecated(reason: "Use `paymentInformation.status` instead")
  """
  Payment information for this member.
  """
  paymentInformation: MemberPaymentInformation!
  """
  The currently redeemed campaign of this member, if any.
  """
  redeemedCampaigns: [RedeemedCampaign!]!
  """
  A breakdown of the total cost of this member's insurance.
  The exact charge every month can vary based on other factors,
  """
  insuranceCost: MemberInsuranceCost!
  """
  Member-specific data related to Referrals (Hedvig Forever)
  """
  referralInformation: MemberReferralInformation!
  travelCertificateSpecifications: TravelCertificateSpecification!
  travelCertificates: [TravelCertificate!]!
  crossSells: [CrossSell!]!
  """
  Fetch all the active contracts for this member. Active contracts include all insurances that are either
  active today, or to-be-active in the future.
  """
  activeContracts: [Contract!]!
  """
  Terminated contracts are all past contracts that have ended.
  """
  terminatedContracts: [Contract!]!
  """
  Fetch all the pending contracts for this member.
  """
  pendingContracts: [PendingContract!]!
  """
  Whether this member is entitled to make a claim, based on their historical contracts.
  """
  isEligibleToMakeClaim: Boolean!
  memberActions: MemberActions
}
type MemberActions {
  memberId: ID!
  sickAbroadAction: SickAbroadAction
  """
  Indicate whether the travel certificate option should be displayed.
  """
  isTravelCertificateEnabled: Boolean
  isMovingEnabled: Boolean
  isConnectPaymentEnabled: Boolean
  isEditCoInsuredEnabled: Boolean
  isCancelInsuranceEnabled: Boolean
  firstVetAction: FirstVetAction
}
"""
Upcoming charge info, null in case of pending or fully settled members
"""
type MemberCharge {
  id: ID
  status: MemberChargeStatus!
  """
  Total gross amount of the upcoming charge based on all contracts premium divided by the number of days in the month
  """
  gross: Money!
  """
  Total net amount of the upcoming charge, (gross - discount)
  """
  net: Money!
  """
  Total discount amount of the upcoming charge, includes all active discounts
  """
  discount: Money!
  """
  Due date of the upcoming charge
  """
  date: Date!
  """
  Breakdown of the upcoming charge by contract
  """
  contractsChargeBreakdown: [MemberChargeContractBreakdownItem!]!
  """
  Breakdown of the upcoming charge's discounts
  """
  discountBreakdown: [MemberChargeDiscountBreakdownItem!]!
  """
  Past charges that have failed
  """
  pastFailedChargeIds: [ID!]!
  """
   usedCredit is the amount that the member has used towards their paid subscription. 
  """
  carriedAdjustment: Money
  """
   gainedCredit is the amount that the member is owed due to settlement adjustment. 
  """
  settlementAdjustment: Money
}
type MemberChargeContractBreakdownItem {
  gross: Money!
  contract: Contract!
  periods: [MemberChargeContractBreakdownItemPeriod!]!
}
type MemberChargeContractBreakdownItemPeriod {
  fromDate: Date!
  toDate: Date!
  amount: Money!
  isPreviouslyFailedCharge: Boolean!
}
type MemberChargeDiscountBreakdownItem {
  code: String
  discount: Money!
  isReferral: Boolean!
}
"""
A charge that was settled or failed
"""
type MemberChargeHistoryEntry {
  """
  The date that the charge was settled or changing its status to pending or failed
  """
  date: Date!
  """
  The amount that was settled
  """
  amount: Money!
  """
  The status of the charge
  """
  status: MemberChargeHistoryEntryStatus!
}
"""
The status of the charge
"""
enum MemberChargeHistoryEntryStatus {
  """
  The charge was settled successfully
  """
  SUCCESS
  """
  The charge is pending that means either has been send to payment-service or to the payment provider
  """
  PENDING
  """
  The charge failed
  """
  FAILED
}
"""
The status of the charge
"""
enum MemberChargeStatus {
  """
  A charge that is upcoming
  """
  UPCOMING
  """
  The charge was settled successfully
  """
  SUCCESS
  """
  The charge is pending that means either has been send to payment-service or to the payment provider
  """
  PENDING
  """
  The charge failed
  """
  FAILED
}
"""
Input for `Mutation.memberDeviceRegister`
"""
input MemberDeviceRegisterInput {
  """
  The token to register.
  """
  token: String!
  """
  The platform this token is connected to.
  """
  platform: AppPlatform!
}
type MemberImportantMessage {
  id: ID!
  message: String! @deprecated(reason: "Use linkInfo instead, which allows for a message to not have a link at all attached and allows editing the button text too")
  link: Url!
  linkInfo: LinkInfo
}
type MemberInsuranceCost {
  """
  Total cost of the insurances before any discounts.
  """
  monthlyGross: Money!
  """
  The total discount when everything is applied.
  """
  monthlyDiscount: Money!
  """
  The total to actually be charged every month.
  """
  monthlyNet: Money!
  """
  Comment copy-pasted from codebase:
  NOTE: this name is misleading, because it's used both for free months and for time limited discounts
  """
  freeUntil: Date
}
"""
Container for mutations that refer to the currently authenticated member.
"""
type MemberMutationOutput {
  member: Member
  userError: UserError
}
type MemberPaymentConnection {
  """
  An abstract display name of the connection - usually like the name of the bank you are connected to.
  """
  displayName: String!
  """
  A more specific description of your actual connection, such as a bank account reference.
  """
  descriptor: String!
}
enum MemberPaymentConnectionStatus {
  """
  The payment connection is good to go.
  """
  ACTIVE
  """
  The payment connection has been partially set up but is awaiting activation.
  """
  PENDING
  """
  There is no payment connection.
  """
  NEEDS_SETUP
}
type MemberPaymentInformation {
  """
  Status of the payment connection. If ACTIVE, a `connection` should be present.
  """
  status: MemberPaymentConnectionStatus!
  """
  A payment connection if registered.
  """
  connection: MemberPaymentConnection
}
type MemberReferral {
  """
  The name of this referral. This reflects the name of the member created through the referral.
  """
  name: String!
  """
  Status of the referral - only ACTIVE referrals generate a discount.
  """
  status: MemberReferralStatus!
  """
  The currently active discount of this referral.
  """
  activeDiscount: Money
}
type MemberReferralInformation {
  """
  The unique invite-code this member that can be sent to other people.
  Can be updated with `Mutation.memberReferralInformationCodeUpdate`
  """
  code: String!
  """
  A value indicating the total amount of discounts this member has excluding the discounts generated
  by referring other people.
  """
  monthlyDiscountExcludingReferrals: Money!
  """
  How much a single successful referral is worth.
  """
  monthlyDiscountPerReferral: Money!
  """
  The referral that ended up with this member signing. This is also overlapped with an entry in redeemedCampaign.
  """
  referredBy: MemberReferral
  """
  All the referrals this connected to this member and their current status.
  """
  referrals: [MemberReferral!]!
}
type MemberReferralInformationMutationOutput {
  referralInformation: MemberReferralInformation
  userError: UserError
}
enum MemberReferralStatus {
  PENDING
  ACTIVE
  TERMINATED
}
"""
Upcoming charge info, null in case of pending or fully settled members
"""
type MemberUpcomingCharge {
  """
  Total gross amount of the upcoming charge based on all contracts premium divided by the number of days in the month
  """
  gross: Money!
  """
  Total net amount of the upcoming charge, (gross - discount)
  """
  net: Money!
  """
  Total discount amount of the upcoming charge, includes all active discounts
  """
  discount: Money!
  """
  Due date of the upcoming charge
  """
  date: Date!
  """
  Breakdown of the upcoming charge by contract
  """
  contractsChargeBreakdown: [ContractChargeBreakdownItem!]!
}
input MemberUpdateEmailInput {
  email: String!
}
input MemberUpdateEurobonusNumberInput {
  eurobonusNumber: String!
}
input MemberUpdateLanguageInput {
  ietfLanguageTag: String!
}
input MemberUpdatePhoneNumberInput {
  phoneNumber: String!
}
type MidtermChangeIntent {
  id: ID!
  currentPremium: Money!
  newPremium: Money!
  activationDate: Date!
  state: MidtermChangeIntentState!
}
input MidtermChangeIntentCreateInput {
  """
  The list of all co-insured to set on the agreement, i.e. size equals nbrOfCoInsured.
  This list contains "null" entries for co-insured not yet defined.
  """
  coInsuredInputs: [CoInsuredInput!]
}
type MidtermChangeIntentMutationOutput {
  intent: MidtermChangeIntent
  userError: UserError
}
enum MidtermChangeIntentState {
  INITIATED
  COMPLETED
}
"""
A monetary value with currency.
"""
type Money {
  amount: Float!
  """
  Currency of the money (ISO 4217).
  """
  currencyCode: CurrencyCode!
}
type MoveAddress {
  """
   Address id, will correlate to the contract id 
  """
  id: ID!
  """
   Address street 
  """
  street: String!
  """
   Address postal code 
  """
  postalCode: String!
  """
   Address city 
  """
  city: String
}
enum MoveApartmentSubType {
  RENT
  OWN
}
input MoveExtraBuildingInput {
  """
   Area of extra building 
  """
  area: Int!
  """
   Extra building type 
  """
  type: MoveExtraBuildingType!
  """
   If extra building has water connected 
  """
  hasWaterConnected: Boolean!
}
enum MoveExtraBuildingType {
  GARAGE
  CARPORT
  SHED
  STOREHOUSE
  FRIGGEBOD
  ATTEFALL
  OUTHOUSE
  GUESTHOUSE
  GAZEBO
  GREENHOUSE
  SAUNA
  BARN
  BOATHOUSE
  OTHER
}
type MoveIntent {
  id: ID!
  """
   The earliest possible move date according to current contracts 
  """
  minMovingDate: Date!
  """
   The latest possible move date according to current contracts 
  """
  maxMovingDate: Date!
  """
   Max number of co-insured for a house to move to
  """
  maxHouseNumberCoInsured: Int
  """
   Max area of a house to move to
  """
  maxHouseSquareMeters: Int
  """
   Max number of co-insured for an apartment to move to
  """
  maxApartmentNumberCoInsured: Int
  """
   Max area of an apartment to move to 
  """
  maxApartmentSquareMeters: Int
  """
   If member is eligable for apartment student insurance 
  """
  isApartmentAvailableforStudent: Boolean
  """
   All available external building types accepted for new address 
  """
  extraBuildingTypes: [MoveExtraBuildingType!]!
  """
   Number of co-insured from existing contract to use as default 
  """
  suggestedNumberCoInsured: Int!
  """
   List of members current addresses possible to move from 
  """
  currentHomeAddresses: [MoveAddress!]!
  """
   Will only be present after moveIntentRequest. The quotes for moving to new address. 
  """
  quotes: [MoveQuote!]!
}
"""
 Only one field can be present 
"""
type MoveIntentMutationOutput {
  """
   Success case 
  """
  moveIntent: MoveIntent
  """
   Fail case 
  """
  userError: UserError
}
input MoveIntentRequestInput {
  """
   The new address to move to 
  """
  moveToAddress: MoveToAddressInput!
  """
   This is the ID you get in MoveIntent:currentHomeAddresses member selected to move from 
  """
  moveFromAddressId: ID!
  """
   The moving date new insurance should be activated 
  """
  movingDate: Date!
  """
   The number of co-insured on new address 
  """
  numberCoInsured: Int!
  """
   The number of square meters of new home 
  """
  squareMeters: Int!
  """
   Data if to move to an apartment 
  """
  apartment: MoveToApartmentInput
  """
   Data if to move to house 
  """
  house: MoveToHouseInput
}
type MoveQuote {
  """
   Premium 
  """
  premium: Money!
  """
   When new insurance (or existing insurance address change) is becoming active 
  """
  startDate: Date!
  """
   List of display items for the quote 
  """
  displayItems: [MoveQuoteDisplayItem!]!
  """
   The insurance exposure name, eg reg nbr for car, name and birthdate for cat/dog, street for home etc... 
  """
  exposureName: String
  """
   The terms 
  """
  productVariant: ProductVariant!
}
type MoveQuoteDisplayItem {
  displayTitle: String!
  displaySubtitle: String
  displayValue: String!
}
input MoveToAddressInput {
  """
   The street to move to 
  """
  street: String!
  """
   The postal code to move to 
  """
  postalCode: String!
  """
   The city to move to 
  """
  city: String
}
input MoveToApartmentInput {
  """
   The subtype of new apartment 
  """
  subType: MoveApartmentSubType!
  """
   If member is student 
  """
  isStudent: Boolean!
}
input MoveToHouseInput {
  """
   The ancillary area of new house 
  """
  ancillaryArea: Int!
  """
   The year of construction of new house 
  """
  yearOfConstruction: Int!
  """
   Number of bathrooms in new house 
  """
  numberOfBathrooms: Int!
  """
   If new house is subleted 
  """
  isSubleted: Boolean!
  """
   Extra buildings for new house 
  """
  extraBuildings: [MoveExtraBuildingInput!]!
}
type Mutation {
  chatSendText(input: ChatMessageTextInput!): ChatSendOutcome!
  chatSendFile(input: ChatMessageFileInput!): ChatSendOutcome!
  """
  Start a conversation. This is effectively creating one, but with two slight differences from a regular
  "create something"-mutation:
  - It lets the clients inject the ID of the conversation, which is useful for the implementation for some clients
  - It is idempotent, so starting it again will simply return the old one unchanged
  """
  conversationStart(input: ConversationStartInput!): Conversation!
  conversationSendMessage(input: ConversationSendMessageInput!): ChatMessageMutationOutput!
  """
  This is a re-implementation of the existing Mutation.externalInsurnaceProvider.initiateIframeDataCollection
  mutation, as the old one uses an unsupported resolver design (nested/namespaced mutations).
  """
  insurelyInitiateIframeDataCollection(input: InsurelyInitiateIframeDataCollectionInput!): InsurelyInitiateIframeDataCollectionOutput!
  memberUpdatePhoneNumber(input: MemberUpdatePhoneNumberInput!): MemberMutationOutput!
  memberUpdateEmail(input: MemberUpdateEmailInput!): MemberMutationOutput!
  memberUpdateLanguage(input: MemberUpdateLanguageInput!): MemberMutationOutput!
  memberDeletionRequest: UserError
  memberUpdateSubscriptionPreference(subscribe: Boolean): UserError
  memberUpdateEurobonusNumber(input: MemberUpdateEurobonusNumberInput!): MemberMutationOutput!
  """
  Register a push-notification token to customer.io (which calls it a "Device").
  """
  memberDeviceRegister(input: MemberDeviceRegisterInput!): Boolean!
  flowClaimStart(input: FlowClaimStartInput!, context: FlowContext): Flow!
  flowClaimConfirmEmergencyNext(input: FlowClaimConfirmEmergencyInput!, context: FlowContext): Flow!
  flowClaimPhoneNumberNext(input: FlowClaimPhoneNumberInput!, context: FlowContext!): Flow!
  flowClaimDateOfOccurrenceNext(input: FlowClaimDateOfOccurrenceInput!, context: FlowContext!): Flow!
  flowClaimContractSelectNext(input: FlowClaimContractSelectInput!, context: FlowContext!): Flow!
  flowClaimPersonSelectNext(input: FlowClaimPersonSelectInput!, context: FlowContext!): Flow!
  flowClaimLocationNext(input: FlowClaimLocationInput!, context: FlowContext!): Flow!
  flowClaimDateOfOccurrencePlusLocationNext(input: FlowClaimDateOfOccurrencePlusLocationInput!, context: FlowContext!): Flow!
  flowClaimAudioRecordingNext(input: FlowClaimAudioRecordingInput!, context: FlowContext!): Flow!
  flowClaimFileUploadNext(input: FlowClaimFileUploadInput!, context: FlowContext!): Flow!
  flowClaimSingleItemNext(input: FlowClaimSingleItemInput!, context: FlowContext!): Flow!
  flowClaimSummaryNext(input: FlowClaimSummaryInput!, context: FlowContext!): Flow!
  flowClaimSingleItemCheckoutNext(input: FlowClaimSingleItemCheckoutInput!, context: FlowContext!): Flow!
  flowTerminationStart(input: FlowTerminationStartInput!, context: FlowContext): Flow!
  flowTerminationDateNext(input: FlowTerminationDateInput!, context: FlowContext!): Flow!
  flowTerminationDeletionNext(input: FlowTerminationDeletionInput, context: FlowContext!): Flow!
  flowTerminationSurveyNext(input: FlowTerminationSurveyInput!, context: FlowContext!): Flow!
  registerDirectDebit2(clientContext: RegisterDirectDebitClientContext2): DirectDebitResponse2!
  """
  Tokenize payment details per member in order to be used in future and returns the status
  """
  tokenizePaymentDetails2(req: TokenizationRequest): TokenizationResponse
  """
  Handle payment redirection, required for 3D Secure verification on cards
  """
  submitAdyenRedirection2(req: SubmitAdyenRedirectionRequest): SubmitAdyenRedirectionResponse!
  travelCertificateCreate(input: TravelCertificateCreateInput!): TravelCertificate!
  """
  Redeem a campaign for the current member with the input `code`.
  """
  memberCampaignsRedeem(code: String!): MemberMutationOutput!
  """
  Remove a campaign for the current member with the given `RedeemedCampaign.id`.
  """
  memberCampaignsUnredeem(id: ID!): MemberMutationOutput!
  """
  Update the personal invite code for the current member.
  This can be personalised to take the original, rather random code like 'OWID23KS' and turn it into
  something more appealing like 'COWABUNGA'.
  """
  memberReferralInformationCodeUpdate(code: String!): MemberReferralInformationMutationOutput!
  """
  Create a `ShopSession`. The `input.countryCode` value will have implications on the behaviour of the session
  in terms of what products can be bought using it and underlying integrations.
  """
  shopSessionCreate(input: ShopSessionCreateInput!): ShopSession!
  """
  Create partner-specific `ShopSession`.  Validates partnerName and may provide partner-specific behaviour.
  """
  shopSessionCreatePartner(input: ShopSessionCreatePartnerInput): ShopSession!
  updateConsent(trialId: UUID!, consentGiven: Boolean!): ConsentResponse
  """
  Set the external insurer ID (value of `ExternalInsurer.id`) for this price intent.
  Mostly used for helping the user with cancellation/switching.
  """
  priceIntentExternalInsurerUpdate(priceIntentId: UUID!, externalInsurerId: ID): PriceIntentMutationOutput!
  """
  Update the 'cancellation requested' value of the given offers. True means that the user wants us
  to help them with switching/cancellation, and false means that they don't.
  """
  productOffersCancellationRequestedUpdate(productOfferIds: [UUID!]!, requested: Boolean!): ProductOffersMutationOutput!
  contractBankSigneringCancellationInitiate(contractId: UUID!): Contract!
  """
  Create a `PriceIntent`.
  The `input.productName` has to be the name of a product among the ones listed at `Query.availableProducts`. The
  choice of product also affects which data will be needed for the intent to be confirmed and to produce offers.
  """
  priceIntentCreate(input: PriceIntentCreateInput!): PriceIntent!
  """
  Update the raw insurance-related data for this `PriceIntent`. This data is mostly related to the insured object
  itself, and not the "holder" of the insurance.
  """
  priceIntentDataUpdate(priceIntentId: UUID!, data: PricingFormData!): PriceIntentMutationOutput!
  """
  Associate a specific Insurely `dataCollectionId` from lookup-service with this PriceIntent.
  """
  priceIntentInsurelyUpdate(priceIntentId: UUID!, dataCollectionId: String!): PriceIntentMutationOutput!
  """
  Confirm this PriceIntent, which will use the current data (and likely `ShopSession.customer`) to generate
  `ProductOffers` that can be added to the cart.
  """
  priceIntentConfirm(priceIntentId: UUID!): PriceIntentMutationOutput!
  """
  Change the start date of the given `ProductOffer`s by their ID.
  This is used because it's common to want to change the start date AFTER getting the offer.
  """
  productOffersStartDateUpdate(productOfferIds: [UUID!]!, startDate: Date!): ProductOffersMutationOutput!
  """
  Update the customer of the shop session. Only non-null fields will be changed.
  Can trigger automatic lookup of other information.
  The session can be placed in a "point of no return" state where it is no longer legal to update the customer,
  which will generate errors.
  """
  shopSessionCustomerUpdate(input: ShopSessionCustomerUpdateInput!): ShopSessionMutationOutput!
  """
  Add a list of `ProductOffer`s by their ID to the cart.
  """
  shopSessionCartEntriesAdd(input: ShopSessionCartEntriesAddInput): ShopSessionMutationOutput!
  """
  Remove a list of `ProductOffer`s by their ID from the cart.
  """
  shopSessionCartEntriesRemove(input: ShopSessionCartEntriesRemoveInput): ShopSessionMutationOutput!
  """
  Try to attach a campaign with the given code to the cart. Returns a `userError` value if the code is invalid.
  """
  shopSessionCartCampaignRedeem(input: ShopSessionCartCampaignRedeemInput!): ShopSessionMutationOutput!
  """
  Remove the given campaign from the cart.
  """
  shopSessionCartCampaignUnredeem(input: ShopSessionCartCampaignUnredeemInput!): ShopSessionMutationOutput!
  """
  Begin signing the session, with the ultimate goal of creating insurances in our system, and possibly
  also creating a new Member.
  Signing is an asynchronous process, where the client must poll using `Query.shopSessionSigning` and follow
  the state changes. Some signing requires external work for the user, such as Swedish BankID signing.
  """
  shopSessionStartSign(shopSessionId: UUID!): ShopSessionSigningMutationOutput!
  """
  Send in the expiry date of current insurance from switcher company, so that we can activate our
  insurance the day after.
  """
  switcherCaseComplete(id: UUID!, currentExpiryDate: Date!): SwitcherCaseMutationOutput!
  partnerWidgetInit(input: PartnerWidgetInitInput!): ShopSession! @deprecated(reason: "To be removed with old widget app")
  """
   Initiate a Move intent 
  """
  moveIntentCreate: MoveIntentMutationOutput!
  """
   Request move 
  """
  moveIntentRequest(intentId: ID!, input: MoveIntentRequestInput!): MoveIntentMutationOutput!
  """
   Accept move 
  """
  moveIntentCommit(intentId: ID!): MoveIntentMutationOutput!
  """
  Send a batch of events to the EventTrackingService
  """
  sendEventBatch(inputList: [EventInput!]!): [ID!]!
  """
  Called to change the co-insured for a contract, returns a generic output containing an intent for the change.
  The id of the intent is used in the midtermChangeIntentCommit mutation to realize the new co-insured.
  """
  midtermChangeIntentCreate(contractId: ID!, input: MidtermChangeIntentCreateInput!): MidtermChangeIntentMutationOutput!
  """
  Commits the midterm change and creates a new agreement for it, takes id of the intent
  """
  midtermChangeIntentCommit(intentId: ID!): MidtermChangeIntentMutationOutput!
}
type PartnerData {
  sas: SasPartnerData
}
type PartnerWidgetData {
  externalRequestId: String!
  trialInfo: PartnerWidgetTrialInfo
}
input PartnerWidgetInitInput {
  partnerId: UUID!
  countryCode: CountryCode!
  externalRequestId: String
  externalMemberId: UUID
}
type PartnerWidgetTrial {
  trialContract: TrialContract!
}
type PartnerWidgetTrialInfo {
  startDate: Date!
  endDate: Date!
  birthDate: Date!
  insuranceData: JSON!
  ssn: String
  firstName: String
  lastName: String
  email: String
  phoneNumber: String
}
scalar PaymentMethodDetails
scalar PaymentMethodsResponse
"""
A pending contract is a proto-contract that has yet to become a fully fledged insurance. It usually means it is meant
to be activated when an existing external insurance has been cancelled (switching).
It is split into its own type, because they are not "real" insurances until they become active ones.
"""
type PendingContract {
  id: UUID!
  """
  Same as `Contract.exposureDisplayName`.
  """
  exposureDisplayName: String!
  """
  Same as `Contract.currentAgreement.premium`.
  """
  premium: Money!
  """
  Same as `Contract.currentAgreement.productVariant`.
  """
  productVariant: ProductVariant!
  """
  Same as `Contract.currentAgreement.displayItems`.
  """
  displayItems: [AgreementDisplayItem!]!
  """
  A value indicating whether Hedvig will help out with the cancellation of the member's existing insurance (true)
  or if the member have to cancel it themselves and get back to us with a requested start date (false).
  """
  externalInsuranceCancellationHandledByHedvig: Boolean!
}
type Peril {
  id: ID!
  title: String!
  description: String!
  info: String!
  shortDescription: String!
  covered: [String!]!
  exceptions: [String!]!
  colorCode: String
}
type PersonalInformation {
  firstName: String!
  lastName: String!
  streetAddress: String!
  postalNumber: String!
  city: String!
}
input PersonalInformationInput {
  personalNumber: String!
}
type PriceIntent {
  """
  The id of the price intent.
  """
  id: UUID!
  """
  The product associated to this price intent
  """
  product: Product!
  """
  Submitted user form data.
  """
  data: PricingFormData!
  """
  Data submitted in other places or inferred from other data points
  """
  suggestedData: PricingFormData!
  """
  The resulting product offers generated by inputting data and confirming the intent.
  """
  offers: [ProductOffer!]!
  """
  When there are offers, pick a suitable default one.  Used in CRM where we want to present single offer per price intent
  """
  defaultOffer: ProductOffer
  """
  The person's current insurance company
  """
  externalInsurer: ExternalInsurer
  insurely: PriceIntentInsurely
  warning: PriceIntentWarning
}
enum PriceIntentAnimal {
  CAT
  DOG
}
type PriceIntentAnimalBreed {
  id: ID!
  displayName: String!
  isMixedBreed: Boolean!
}
input PriceIntentCreateInput {
  shopSessionId: UUID!
  """
  The human readable, logical name that identifies the product. I.e. `SE_APARTMENT_BRF` or similar.
  """
  productName: String!
}
input PriceIntentFilters {
  uniqueConfirmed: Boolean
}
type PriceIntentInsurely {
  configName: ID!
  partner: ID!
}
type PriceIntentMutationOutput {
  priceIntent: PriceIntent
  userError: UserError
}
type PriceIntentWarning {
  """
  Localized display header warning user about a potential issue with their price intent e.g. their car is decommissioned
  """
  header: String
  """
  Localized display message warning user about a potential issue with their price intent e.g. their car is decommissioned
  """
  message: String
}
"""
The raw insurance-related data that can be given to a `PriceIntent` in order to generate offers.
This data is mostly related to the insured object itself, and not the "holder" of the insurance.
Examples of common fields:
- `street`
- `zipCode`
- `registrationNumber` (car)
Examples of fields not found here:
- `firstName` (see: `ShopSession.customer`)
- `email` (see: `ShopSession.customer`)
"""
scalar PricingFormData
"""
A `Product` is a data type representing a group of insurances that share certain characteristics and are packaged
together from the user perspective as a single entry on the store.
The user will view it and think of it as a specific insurance, but under the hood it can be ultimately translated
into different `ProductVariant`s and ultimately different specific insurances depending on the data sent in
by the user in the `PriceIntent`.
"""
type Product {
  id: ID!
  """
  A unique, human readable, identifier of the product
  """
  name: String!
  """
  Return all the possible `ProductVariants` that can come out of this Product
  """
  variants: [ProductVariant!]!
  """
  Localized name of the product in short form.
  """
  displayNameShort: String!
  """
  Localized name of the product in long form.
  """
  displayNameFull: String!
  """
  Localized tagline of the product.
  """
  tagline: String!
  """
  The pillow image asset associated with this product.
  """
  pillowImage: StoryblokImageAsset!
  """
  The featured image asset associated with this product.
  """
  featuredImage: StoryblokImageAsset
  """
  Relative URL to the detail page of this product.
  """
  pageLink: String!
  """
  Relative URL to the category page of this product.
  """
  categoryPageLink: String
  """
  A list of the external insurers valid for this specific product.
  """
  externalInsurers: [ExternalInsurer!]!
  developerValues: ProductDeveloperValues!
}
type ProductDeveloperValues {
  fields: JSON!
  exampleFormData: PricingFormData!
}
type ProductOffer {
  """
  The id of this item, which can be used to add to cart.
  """
  id: UUID!
  """
  The product this offer is tied to.
  """
  product: Product!
  """
  The variant of product that this offer resembles.
  """
  variant: ProductVariant!
  """
  The cost of this offer
  """
  cost: ProductOfferCost!
  """
  Exposure (insured object) summary
  """
  exposure: ProductOfferExposure!
  """
  The start date of the insurance
  """
  startDate: Date
  """
  Information about a price match with an external insurance
  """
  priceMatch: ProductOfferPriceMatch
  """
  ID of original priceIntent. Some offers (ex. recommendations) come from other sources and don't have priceIntent
  """
  priceIntentId: UUID
  """
  The form data used to generate the offer
  """
  priceIntentData: PricingFormData!
  """
  Data for presenting offer summary
  """
  displayItems: [ProductOfferDisplayItem!]!
  """
  The deductible description of this offer, if there is one.
  """
  deductible: ProductOfferDeductible
  """
  Values related to cancellation/switching of their existing other insurance.
  """
  cancellation: ExternalInsuranceCancellation!
}
type ProductOfferCost {
  """
  Price you will pay after discount.
  """
  net: Money!
  """
  Original price.
  """
  gross: Money!
  """
  How much price was reduced.
  """
  discount: Money!
  discountMonths: Int!
}
type ProductOfferDeductible {
  displayName: String!
  tagline: String!
}
"""
Formatted and localized entry of pricing data
"""
type ProductOfferDisplayItem {
  """
  Field name as represented in PricingFormData
  """
  key: String!
  """
  Field technical value.  Clients may use it to build better visual representation than text-only displayValue
  """
  value: JSON!
  """
  Localized field title
  """
  displayTitle: String!
  """
  Localized display value
  """
  displayValue: String!
}
"""
Generic summary of insured object
"""
type ProductOfferExposure {
  """
  Ex. 'REG 123' for car
  """
  displayNameShort: String!
  """
  Ex. 'Fakestreet 124 * You+1' for home
  """
  displayNameFull: String!
}
type ProductOfferPriceMatch {
  externalPrice: Money!
  externalInsurer: ExternalInsurer!
  priceReduction: Money!
}
type ProductOffersMutationOutput {
  productOffers: [ProductOffer!]!
  userError: UserError
}
"""
A recommendation is a suggestion by the platform for a specific product that might be of interest
to the user based on input so far.
Some recommendations even have a pre-packaged `ProductOffer` that can be added to the cart immediately,
if the user has input enough information to generate it.
"""
type ProductRecommendation {
  product: Product!
  offer: ProductOffer
}
type ProductVariant {
  """
  A `ProductVariant` is identified by its terms version, which is the more technical
  name for a unique incarnation of our insurances (products) at a point in time.
  """
  termsVersion: ID!
  typeOfContract: String!
  partner: String
  perils: [Peril!]!
  insurableLimits: [InsurableLimit!]!
  documents: [InsuranceDocument!]!
  highlights: [InsuranceHighlight!]!
  faq: [InsuranceFaq!]!
  """
  The full name of this product variant.
  """
  displayName: String!
  """
  A shorter name of that highlights in which way it distinguishes itself from other similar insurances.
  """
  displayNameSubtype: String!
  """
  Get a list of 'common claim descriptions' for this product variant.
  This can contain content such as 'sick abroad' or 'broken phone' for a home insurance, for instance.
  """
  commonClaimDescriptions: [CommonClaimDescription!]!
}
type Query {
  chat("The latest until timestamp when you want to fetch more messages than before" until: Instant): Chat!
  chatGifs(query: String): [ChatGif!]!
  """
  Return a conversation for a given ID.
  Note that this can return null if `Mutation.conversationStart` has not been called with this ID.
  """
  conversation(id: UUID!): Conversation
  personalInformation(input: PersonalInformationInput!): PersonalInformation
  """
  Gets the currently authenticated member. This is the only valid way to query a `Member` type, and it is based
  on the input Authorization header.
  """
  currentMember: Member!
  entrypointGroups(type: EntrypointType!): [EntrypointGroup!]!
  entrypointSearch(input: EntrypointSearchInput): [Entrypoint!]!
  """
  Returns all the available payments methods before the client requests a tokenization
  """
  availablePaymentMethods2: AvailablePaymentMethodsResponse!
  shopSession(id: UUID!): ShopSession!
  carTrial(contractId: UUID!): TrialExtension
  petMigrationOffers(shopSessionId: UUID!): [ProductOffer!]!
  """
  Outcome of shopSession.  Requires authentication
  Available forever, unlike shopSession which becomes hidden some time after creation
  """
  shopSessionOutcome(id: UUID!): ShopSessionOutcome
  priceIntent(id: UUID!): PriceIntent!
  priceIntentAvailableBreeds(animal: PriceIntentAnimal!): [PriceIntentAnimalBreed!]!
  availableProducts(partnerName: String): [Product!]!
  product(productName: String!, partnerName: String): Product
  shopSessionSigning(id: UUID!): ShopSessionSigning!
  switcherCase(id: UUID!): SwitcherCase!
  """
  Resolve a single contract by its ID. Requires the caller to be a member owning said contract.
  """
  contract(id: UUID!): Contract!
  """
  Resolve a single Trial contract by its ID. Does NOT require the caller to be a member owning said contract.
  """
  trialContract(id: UUID!): TrialContract!
}
"""
A type describing a redeemed campaign.
"""
type RedeemedCampaign {
  id: ID!
  """
  The code the user input to attach this campaign.
  """
  code: String!
  """
  A user-readable description of this campaign.
  """
  description: String!
  """
  The discount information from this campaign.
  """
  discount: CampaignDiscount!
  """
  REFERRAL (you were invited by a friend) or VOUCHER (this is some kind of limited discount or similar)
  """
  type: RedeemedCampaignType!
  """
  The expiry of this campaign, this is non-null if the following is true:
  - It is a kind of campaign that has an expiry (i.e. NOT a referral)
  - It has been successfully redeemed by a signed member (i.e. not only in a ShopSession)
  """
  expiresAt: Date
  """
  Lists the currently active contracts that this campaign is applicable to.
  If this is applicable to ALL insurances, `null` is returned. Otherwise we return the contracts here.
  NOTE: The implementation of this is rather cursed, and thus this should be used sparingly.
  """
  onlyApplicableToContracts: [Contract!]
}
enum RedeemedCampaignType {
  """
  Invited by a friend (Hedvig Forever)
  """
  REFERRAL
  """
  Some kind of discount usually created in Hope.
  """
  VOUCHER
}
input RegisterDirectDebitClientContext2 {
  successUrl: String!
  failureUrl: String!
}
type SasPartnerData {
  eligible: Boolean!
  eurobonusNumber: String
}
type ShopSession {
  id: UUID!
  """
  The country this session was created with.
  """
  countryCode: CountryCode!
  """
  The currency associated with the country of the session.
  """
  currencyCode: CurrencyCode!
  """
  Creation timestamp.
  """
  created: DateTime!
  """
  Product recommendations for the member (this field is authenticated).
  """
  recommendations: [ProductRecommendation!]!
  """
  The full list of created price intents in this session
  """
  priceIntents(filters: PriceIntentFilters): [PriceIntent!]!
  """
  Website URLs for API operations on this session
  """
  urls: ShopSessionUrls!
  """
  Feature flags and experiment eligibility
  """
  experiments: ShopSessionExperiments
  """
  The Cart value of this shop session, carrying offers currently awaiting checkout.
  """
  cart: Cart!
  """
  The outcome of a signed shop-session. Requires authentication.
  """
  outcome: ShopSessionOutcome
  """
  The customer value of the session. Can be updated through a mutation.
  The initial value is:
  - null if the session was created without authentication
  - non-null if the session was created as a logged in member
  """
  customer: ShopSessionCustomer
  """
  Indicates when this shop session was signed successfully. Not set if signing attempts fail.
  """
  signedAt: DateTime!
  partnerWidgetData: PartnerWidgetData @deprecated(reason: "To be removed with old widget web app. New implementation uses partnerWidgetTrial for trials and generic info everywhere else")
  partnerName: String
  """
  Trial-specific info for trial insurances supported in widget flows (no Car Trials, for example)
  """
  partnerWidgetTrial: PartnerWidgetTrial
}
input ShopSessionCartCampaignRedeemInput {
  shopSessionId: UUID!
  code: String!
}
input ShopSessionCartCampaignUnredeemInput {
  shopSessionId: UUID!
  campaignId: String!
}
input ShopSessionCartEntriesAddInput {
  shopSessionId: UUID!
  offerIds: [UUID!]!
}
input ShopSessionCartEntriesRemoveInput {
  shopSessionId: UUID!
  offerIds: [UUID!]!
}
input ShopSessionCreateInput {
  countryCode: CountryCode!
  attributedTo: String
  initiatedFrom: String
}
input ShopSessionCreatePartnerInput {
  countryCode: CountryCode!
  """
  Known partner name, case-insensitive
  """
  partnerName: String!
  """
  Will be used for webhooks if provided. Otherwise random UUID will be generated
  """
  partnerRequestId: String
  """
  Used for matching trial data with earlier trial created via backed API
  """
  externalMemberId: String
  initiatedFrom: String
  """
  Optional campaign code if partner configuration support this
  """
  campaignCode: String
}
"""
The customer is a type containing information about the user interacting with the Store.
This can either contain data actively provided through the customer update mutation, but also data automatically
looked up based on things like ssn.
This data will ultimately be translated into `holder` information of the underlying insurance.
"""
type ShopSessionCustomer {
  """
  The personal number of the customer. Can be used for looking up other information.
  """
  ssn: String
  """
  The list of fields that need to be added in order to sign properly.
  Can be updated through `Mutation.shopSessionCustomerUpdate`.
  """
  missingFields: [ShopSessionCustomerMissingField!]!
}
enum ShopSessionCustomerMissingField {
  FIRST_NAME
  LAST_NAME
  EMAIL
  PHONE_NUMBER
}
input ShopSessionCustomerUpdateInput {
  shopSessionId: UUID!
  ssn: String
  email: String
  phoneNumber: String
  firstName: String
  lastName: String
}
type ShopSessionExperiments {
  bundleDiscount: Boolean
}
type ShopSessionMutationOutput {
  shopSession: ShopSession
  userError: UserError
}
"""
Contains relevant post-sign objects of the shop-session. After a shop session is completed, this object is added to
the shop-session and can be used to perform necessary post-sign actions, such as external insurance cancellation.
"""
type ShopSessionOutcome {
  id: UUID!
  """
  List all the properly created contracts from the completed shop session.
  Note that this will not contain and `PendingContract`s.
  """
  createdContracts: [Contract!]!
}
type ShopSessionSigning {
  id: UUID!
  """
  The status of this signing.
  """
  status: ShopSessionSigningStatus!
  """
  Properties present if this is a signing through Swedish BankID.
  """
  seBankidProperties: ShopSessionSigningSeBankidProperties
  """
  The token that can be used to trigger an immediate switch to the BankID app on the same device.
  """
  seBankidAutoStartToken: String @deprecated(reason: "Use `seBankidProperties` instead")
  """
  The data to put inside a QR code and to be scanned by the BankID app. Should be polled
  and updated continuously.
  """
  seBankidLiveQrCodeData: String @deprecated(reason: "Use `seBankidProperties` instead")
  """
  A value that will be present if status is SIGNED.
  """
  completion: ShopSessionSigningCompletion
  """
  A value that will be present if status is FAILED.
  """
  userError: UserError
}
type ShopSessionSigningCompletion {
  """
  A value that can be used to create an accessToken/refreshToken pair from the auth service. This is used
  to let the user become a fully logged in member automatically after signing their insurance.
  """
  authorizationCode: String!
}
type ShopSessionSigningMutationOutput {
  signing: ShopSessionSigning
  userError: UserError
}
type ShopSessionSigningSeBankidProperties {
  """
  The token that can be used to trigger an immediate switch to the BankID app on the same device.
  """
  autoStartToken: String!
  """
  The data to put inside a QR code and to be scanned by the BankID app. Should be polled
  and updated continuously.
  """
  liveQrCodeData: String!
  """
  A boolean value that will flip to true if we detect that the session has been registered in the BankID app.
  This either happens through auto-start or by scanning the live QR code.
  """
  bankidAppOpened: Boolean!
}
enum ShopSessionSigningStatus {
  """
  Signing still in-process, and is awaiting action from the user, such as using an external BankID service.
  """
  PENDING
  """
  The signing failed for some reason. Could be that it was cancelled by the user or something else.
  """
  FAILED
  """
  This state indicates that the signing is accepted, but is actively being rolled out through the system.
  The front-end can use this value to display progress feedback to the user if wanted.
  """
  CREATING
  """
  This means the signing has completed successfully.
  """
  SIGNED
}
type ShopSessionUrls {
  """
  Link to retargeting flow for CRM
  See https://github.com/HedvigInsurance/racoon/blob/main/apps/store/src/features/retargeting/README.md
  """
  retargeting: String!
}
type SickAbroadAction {
  partners: [SickAbroadPartner!]!
}
type SickAbroadPartner {
  id: ID!
  imageUrl: Url
  url: Url
  phoneNumber: String
}
type StoryblokImageAsset {
  id: ID!
  src: String!
  alt: String
}
input SubmitAdyenRedirectionRequest {
  md: String!
  pares: String!
}
type SubmitAdyenRedirectionResponse {
  resultCode: String!
}
"""
Represents a case of switching, pointing towards a soon-to-be insurance Contract on our platform.
If it is not completed, it can be by calling `Mutation.switcherCaseComplete`.
"""
type SwitcherCase {
  id: UUID!
  """
  If true, this can no longer be changed.
  """
  isCompleted: Boolean!
}
type SwitcherCaseMutationOutput {
  switcherCase: SwitcherCase
  userError: UserError
}
enum TokenizationChannel {
  ANDROID
  IOS
  WEB
}
input TokenizationRequest {
  paymentMethodDetails: PaymentMethodDetails!
  channel: TokenizationChannel!
  browserInfo: BrowserInfo
  returnUrl: String!
}
union TokenizationResponse = TokenizationResponseFinished|TokenizationResponseAction
type TokenizationResponseAction {
  action: CheckoutPaymentsAction!
}
type TokenizationResponseFinished {
  resultCode: String!
  tokenizationResult: TokenizationResultType!
}
enum TokenizationResultType {
  COMPLETED
  PENDING
  FAILED
}
type TravelCertificate {
  id: ID!
  signedUrl: Url!
  startDate: Date!
  endDate: Date
  expiryDate: Date!
}
type TravelCertificateContractSpecification {
  contractId: ID!
  minStartDate: Date!
  maxStartDate: Date!
  maxDurationDays: Int!
  numberOfCoInsured: Int!
  location: Location
}
input TravelCertificateCreateCoInsured {
  fullName: String!
  ssn: String
  dateOfBirth: Date
}
input TravelCertificateCreateInput {
  contractId: String!
  startDate: Date!
  endDate: Date
  isMemberIncluded: Boolean!
  coInsured: [TravelCertificateCreateCoInsured!]!
  email: String!
}
type TravelCertificateInfoSpecification {
  title: String!
  body: String!
}
type TravelCertificateSpecification {
  infoSpecifications: [TravelCertificateInfoSpecification!]! @deprecated(reason: "Not used anymore, will be removed")
  contractSpecifications: [TravelCertificateContractSpecification!]!
}
"""
A TrialContract is a contract for which it's insuranceType is considered pending. This is a
special simplified contract view of those contracts, which can be fetched without being member-authenticated.
"""
type TrialContract {
  id: UUID!
  """
  Same as `Contract.exposureDisplayName`.
  """
  exposureDisplayName: String!
  """
  Same as `Contract.currentAgreement.activeFrom`.
  """
  activeFrom: Date!
  """
  Same as `Contract.currentAgreement.activeTo`.
  """
  activeTo: Date
  """
  Same as `Contract.currentAgreement.displayItems`.
  """
  displayItems: [AgreementDisplayItem!]!
  """
  Same as `Contract.currentAgreement.premium`.
  """
  premium: Money!
  """
  Same as `Contract.currentAgreement.productVariant`.
  """
  productVariant: ProductVariant!
  """
  Same as `Contract.terminationDate`.
  """
  terminationDate: Date
}
type TrialExtension {
  id: UUID!
  priceIntent: PriceIntent!
  trialContract: TrialContract!
  shopSession: ShopSession!
  collectConsent: Boolean!
  consentGiven: Boolean!
}
scalar Url
"""
A data type returned by certain mutations that is meant to carry user-displayable and localized
messages.
The errors are usually translated through the `Hedvig-Language` header.
"""
type UserError {
  message: String
}
scalar UUID
type ValueArray {
  value: [String!]
}
type ValueBoolean {
  value: Boolean
}
type ValueDate {
  value: Date
}
type ValueInteger {
  value: Int
}
type ValueString {
  value: String
}
union ValueType = ValueString|ValueInteger|ValueBoolean|ValueDate|ValueArray
"""
A GraphQL Schema defines the capabilities of a GraphQL server. It exposes all available types and directives on the server, as well as the entry points for query, mutation, and subscription operations.
"""
type __Schema {
  description: String
  """
  A list of all types supported by this server.
  """
  types: [__Type!]!
  """
  The type that query operations will be rooted at.
  """
  queryType: __Type!
  """
  If this server supports mutation, the type that mutation operations will be rooted at.
  """
  mutationType: __Type
  """
  If this server support subscription, the type that subscription operations will be rooted at.
  """
  subscriptionType: __Type
  """
  A list of all directives supported by this server.
  """
  directives: [__Directive!]!
}
"""
The fundamental unit of any GraphQL Schema is the type. There are many kinds of types in GraphQL as represented by the `__TypeKind` enum.
Depending on the kind of a type, certain fields describe information about that type. Scalar types provide no information beyond a name, description and optional `specifiedByURL`, while Enum types provide their values. Object and Interface types provide the fields they describe. Abstract types, Union and Interface, provide the Object types possible at runtime. List and NonNull types compose other types.
"""
type __Type {
  kind: __TypeKind!
  name: String
  description: String
  specifiedByURL: String
  fields(includeDeprecated: Boolean = false): [__Field!]
  interfaces: [__Type!]
  possibleTypes: [__Type!]
  enumValues(includeDeprecated: Boolean = false): [__EnumValue!]
  inputFields(includeDeprecated: Boolean = false): [__InputValue!]
  ofType: __Type
}
"""
An enum describing what kind of type a given `__Type` is.
"""
enum __TypeKind {
  """
  Indicates this type is a scalar.
  """
  SCALAR
  """
  Indicates this type is an object. `fields` and `interfaces` are valid fields.
  """
  OBJECT
  """
  Indicates this type is an interface. `fields`, `interfaces`, and `possibleTypes` are valid fields.
  """
  INTERFACE
  """
  Indicates this type is a union. `possibleTypes` is a valid field.
  """
  UNION
  """
  Indicates this type is an enum. `enumValues` is a valid field.
  """
  ENUM
  """
  Indicates this type is an input object. `inputFields` is a valid field.
  """
  INPUT_OBJECT
  """
  Indicates this type is a list. `ofType` is a valid field.
  """
  LIST
  """
  Indicates this type is a non-null. `ofType` is a valid field.
  """
  NON_NULL
}
"""
Object and Interface types are described by a list of Fields, each of which has a name, potentially a list of arguments, and a return type.
"""
type __Field {
  name: String!
  description: String
  args(includeDeprecated: Boolean = false): [__InputValue!]!
  type: __Type!
  isDeprecated: Boolean!
  deprecationReason: String
}
"""
Arguments provided to Fields or Directives and the input fields of an InputObject are represented as Input Values which describe their type and optionally a default value.
"""
type __InputValue {
  name: String!
  description: String
  type: __Type!
  """
  A GraphQL-formatted string representing the default value for this input value.
  """
  defaultValue: String
  isDeprecated: Boolean!
  deprecationReason: String
}
"""
One possible value for a given Enum. Enum values are unique values, not a placeholder for a string or numeric value. However an Enum value is returned in a JSON response as a string.
"""
type __EnumValue {
  name: String!
  description: String
  isDeprecated: Boolean!
  deprecationReason: String
}
"""
A Directive provides a way to describe alternate runtime execution and type validation behavior in a GraphQL document.
In some cases, you need to provide options to alter GraphQL's execution behavior in ways field arguments will not suffice, such as conditionally including or skipping a field. Directives provide this by describing additional information to the executor.
"""
type __Directive {
  name: String!
  description: String
  isRepeatable: Boolean!
  locations: [__DirectiveLocation!]!
  args(includeDeprecated: Boolean = false): [__InputValue!]!
}
"""
A Directive can be adjacent to many parts of the GraphQL language, a __DirectiveLocation describes one such possible adjacencies.
"""
enum __DirectiveLocation {
  """
  Location adjacent to a query operation.
  """
  QUERY
  """
  Location adjacent to a mutation operation.
  """
  MUTATION
  """
  Location adjacent to a subscription operation.
  """
  SUBSCRIPTION
  """
  Location adjacent to a field.
  """
  FIELD
  """
  Location adjacent to a fragment definition.
  """
  FRAGMENT_DEFINITION
  """
  Location adjacent to a fragment spread.
  """
  FRAGMENT_SPREAD
  """
  Location adjacent to an inline fragment.
  """
  INLINE_FRAGMENT
  """
  Location adjacent to a variable definition.
  """
  VARIABLE_DEFINITION
  """
  Location adjacent to a schema definition.
  """
  SCHEMA
  """
  Location adjacent to a scalar definition.
  """
  SCALAR
  """
  Location adjacent to an object type definition.
  """
  OBJECT
  """
  Location adjacent to a field definition.
  """
  FIELD_DEFINITION
  """
  Location adjacent to an argument definition.
  """
  ARGUMENT_DEFINITION
  """
  Location adjacent to an interface definition.
  """
  INTERFACE
  """
  Location adjacent to a union definition.
  """
  UNION
  """
  Location adjacent to an enum definition.
  """
  ENUM
  """
  Location adjacent to an enum value definition.
  """
  ENUM_VALUE
  """
  Location adjacent to an input object type definition.
  """
  INPUT_OBJECT
  """
  Location adjacent to an input object field definition.
  """
  INPUT_FIELD_DEFINITION
}
directive @defer (label: String, if: Boolean! = true) on FRAGMENT_SPREAD|INLINE_FRAGMENT
"""
Directs the executor to include this field or fragment only when the `if` argument is true.
"""
directive @include ("Included when true." if: Boolean!) on FIELD|FRAGMENT_SPREAD|INLINE_FRAGMENT
"""
Directs the executor to skip this field or fragment when the `if` argument is true.
"""
directive @skip ("Skipped when true." if: Boolean!) on FIELD|FRAGMENT_SPREAD|INLINE_FRAGMENT
"""
Marks an element of a GraphQL schema as no longer supported.
"""
directive @deprecated ("Explains why this element was deprecated, usually also including a suggestion for how to access supported similar data. Formatted using the Markdown syntax, as specified by [CommonMark](https:\/\/commonmark.org\/)." reason: String = "No longer supported") on FIELD_DEFINITION|ARGUMENT_DEFINITION|INPUT_FIELD_DEFINITION|ENUM_VALUE
"""
Exposes a URL that specifies the behavior of this scalar.
"""
directive @specifiedBy ("The URL that specifies the behavior of this scalar." url: String!) on SCALAR
schema {
  query: Query
  mutation: Mutation
}
